# Lambda изрази и Stream API

## 1. Анализ на данни за планински върхове

В задачата ще имплементираме клас, който ще предоставя статистика върху dataset с най-високите планински върхове в света. Данните ще бъдат предоставени на вашата имплементация като файл, в който всеки ред съдържа данни за един връх в CSV (Comma-Separated Values) формат както следва:

`Позиция,Име,Височина,Изпъкналост,Планина,Година,Брой изкачвания`

Допълнителни разяснения към данните:

  - Позиция по височина - мястото по височина на съответния връх
  - Име (на върха)
  - Височина (в метри)
  - Изпъкналост (в метри) - показва височината на върха от най-високата седловина, свързваща го с по-висок връх) (виж [Topographic prominence](https://en.wikipedia.org/wiki/Topographic_prominence))
  - Планина – от коя планинска верига е част върхът
  - Година на първо изкачване
  - Брой изкачвания след 2004 г.

### Предизвикателство

Всеки един от методите, описани по-долу, може да бъде имплементиран в чист функционален стил - опитайте да решите условието без да ползвате statements / мутация на данни или странични ефекти (включително Stream.forEach).

### Обработка на данните

Класът `Peak` е immutable и ще представя данните за един връх. С цел удобна работа с lambda изрази, ще създаваме обекти от такъв тип чрез статичния factory method `createPeak`.

Създайте имплементация, която приема ред от dataset-a и връща инстанция на `Peak`. Може да разчитате, че данните са в коректен формат - типа им може да видите от предоставения source.

```java
public static Peak createPeak(String line);
```

След като имаме подходящ обект, можем да заредим данните в поток и (декларативно) да изведем разнообразни статистики. Класът, който ще ни предоставя API за статистиките, е `PeakStats`. За начало, имплементирайте конструктора му.

```java
// Изчита dataset-а и инициализира променливата peaks. Ще запазим
// върховете като List, за може да взимаме многократно Stream обект.
public PeakStats(String datasetPath)
```

### Статистики

`PeakStats` предоставя на ползвателите си полезни статистически данни чрез няколко метода. Създайте конкретна имплементация на всеки един от тях, която да отговаря на зададеното условие.

1. Определете височината на най-ниския връх, който никога не е бил изкачван

```java
public double shortestNotAscended();
```

2. Какъв е средният брой изкачвания на върховете в топ N (включително)? Да се върне 0.0, ако няма изкачен връх в интервала.

```java
public double avgAscentsTopN(int n);
```

3. Сред най-високите върхове има и такива, които имат относително малка изпъкналост - например четвъртият по височина връх Лхотце има скромните 610 м., за сравнение - първенецът на Балканите - Мусала - има цели 2473 м. Да се напише метод, който приема изпъкналост и връща като стойност на кое място би се наредил върхът спрямо данните от нашия dataset. Ако има върх(ове) със същата изпъкналост, считаме, че върхът с подадената изпъкналост е по-висок от тях т.е. ще има по-предна позиция.

```java
public long getPositionByProminence(double prominence);
```

4. Най-високият връх, изкачен през дадена година. Ако няма върхове, изкачени през тази година, да се хвърля `java.lang.IllegalArgumentException`.

```java
public Peak getHighestAscentPerYear(int year);
```

5. Имената на върховете, които не са част от Хималаите (която и да е планина, съдържащa `'Himalaya'` в името си), подредени по изпъкналост (от най-висок към най-нисък)

```java
List<String> getNonHimalayaNamesByProminence();
```

6. Коя планинска верига има най-много върхове в топ N (включително)? Да се изведе името ѝ. Ако няколко планински вериги имат равен резултат, няма значение коя от тях ще се върне.

```java
public String getRangeWithMostPeaks(int topN);
```

### Извеждане на данни в табличен вид

В допълнение на предоставените статистики, ползвателите на нашата имплементация искат да могат да си извеждат в табличен вид списък с върховете в даден интервал. Пример:

```
--------------------------------------------------    (1)
| Name                 |     Height | Prominence |    (2)
--------------------------------------------------    (1)
| Mount Everest        |    8848.00 |    8848.00 |    (3)
| K2                   |    8611.00 |    4017.00 |    (3)
| Kangchenjunga        |    8586.00 |    3922.00 |    (3)
| Lhotse               |    8516.00 |     610.00 |    (3)
--------------------------------------------------    (1)
```

Като програмисти знаем, че форматирането на низовете може да бъде tricky операция, а конкатенацията е много скъпа. Използването на mutable обект като `java.lang.StringBuilder` значително оптимизира бързодействието, но с цената на "грозен" код.

В тази част на задачата ще имплементираме функционалност, която извежда таблицата изцяло чрез Stream API.

За да опростим задачата, ще разгледаме таблицата като съвкупност от следните компоненти (цифрата в скоби е легенда спрямо таблицата по-горе):

  - tableHeader - състои се от dashRow(1), titleRow(2), dashRow(1).
  - tableBody - състои се от n bodyRows(3)
  - tableFooter - един dashRow(1)

Като първа стъпка, ще имплементираме няколко статични метода в класа `TableFormatter`. Класът съдържа няколко константи и два вече имплементирани метода

1. Предоставете имплементация на `dashGen()`. Методът трябва да връща безкраен поток от '-', за да може да си генерираме лесно и удобно редове, състоящи се от тирета.

```java
Stream<String> dashGen();
```

2. След това имплементирайте `dashRow()`, използвайки `dashGen()`. Лесно можем да си превърнем потока в краен и да сглобим елементите в единичен низ

```java
String dashRow();
```

3. За да върнем поток с три реда на tableHeader (dashRow + titleRow + dashRow), имплементирайте съответния метод. Функцията, която сглобява titleRow, ви е предоставена.

```java
Stream<String> tableHeader()
```

4. Последният статичен метод, който трябва да напишем в този клас, е `bodyRow`. Методът приема `Peak` обект и връща ред (низ, съдържащ име, височина и изпъкналост, разделени с '|')

Условия към форматирането:

  - името на върха да бъде максимум 20 символа, а ако е повече - да се "отреже", ляво подравнен
  - височина и изпъкналост са с 10 символа, 2 знака след десетичната запетая, дясно подравнени

```java
String bodyRow(Peak peak)
```

5. Следва забавната част - след като имаме всички редове на таблицата, сме готови да я сглобим. Връщаме се отново в `PeakStats`, където имаме:

```java
// Интервалът от върхове, който искаме да листнем. И двата индекса са inclusive
public String listPeaks(int from, int to);
```

Най-лесният начин да имплементираме функцията би бил да си вземем три Stream-a (header, body, footer), да ги обединим в един общ Stream и чрез reduce да върнем единичен низ.

Създайте JUnit тестове за имплементацията.

# Работа с файлове

## 2. Реплициране на съдържанието на директория

Имплементирайте Java приложение, което реплицира съдържанието на директория. Приложението трябва да:

1. Копира всички файлове и директории (рекурсивно) от дадена source директория в дадена target директория. Файловете от source директорията, които вече съществуват в target директорията, не трябва да се копират (презаписват върху съществуващите).

2. Изтрива всички файлове в target директорията, които не съществуват в source директорията

В пакета `bg.uni.sofia.fmi.mjt.replicator` създайте клас `DirectoryReplicator` със следния публичен метод:

```java
public void replicate(Path sourceDir, Path targetDir)
```

В случай че `sourceDir` и/или `targetDir` не съществуват или не са директории, методът да хвърля `IllegalArgumentException`.

Създайте JUnit тестове за имплементацията.
